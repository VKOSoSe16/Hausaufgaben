\documentclass[a4paper]{article}
\usepackage[ngerman]{babel}  
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{nicefrac}

\usepackage{../gail}
\usepackage{../dadp}
\usepackage{../makrocol}

\setfirstauthor{Walter Stieben}
\setfirstauthorID{4stieben@inf}
\setsecondauthor{Tim Reipschläger}
\setsecondauthorID{4reipsch@inf}
\setthirdauthor{Louis Kobras}
\setthirdauthorID{4kobras@inf}
\setfourthauthor{Hauke Stieler}
\setfourthauthorID{4stieler@inf}
\settitle{Lösungsstrategien für NP-schwere Probleme der
Kombinatorischen Optimierung}
\setsheetnumber{6}
\setstartdate{2016}{04}{11}
\setdatefreq{7}
\setinterruptions{1}
\setsectionstyletasksalphnum{}

\begin{document}
	\maketitle
	\section{}
		\subsubsection{}
		Zu zeigen ist, dass der angegebene Algorithmus kein 2-Approximationsalgorithmus ist. Zeigen kann man das mit einem Gegenbeispiel:\n
		Sei $A=\{1, 2, 8\}$ und $B=10$. Der Algorithmus findet nun folgende Mengen:
		\begin{center}
			\begin{tabular}{c|c}
				Index $i$ & Gefundene Menge $S$\\\hline
				1 & $\{1\}$\\
				2 & $\{1, 2\}$\\
				3 & $\{1, 2\}$\\
			\end{tabular}
		\end{center}
		Der Algorithmus nimmt keine Zahlen mehr ab dem Index auf, da dann die Bedingung $\sum\limits_{a_i\in S} a_i\leq B$ nicht mehr gelten würde, da $1+2+8=11>10$ gilt.\n
		Das Ergebnis erfüllt somit nicht die Bedingung eines $\rho$-Approqimationsalgorithmus für Maximierungsprobleme $L^*/L_A\leq \rho$. Stattdessen gilt für das Ergebnis $L_A=3$, die totale Summe $L^*=B=10$ und $\rho=2$ die Gleichung $L^*/L_A=10/3=\overline{3,3}\not\leq\rho$.\n
		Damit ist der angegebene Algorithmus kein 2-Approximationsalgorithmus.\qed
		\subsubsection{}
		\alglanguage{pseudocode}
		\begin{breakablealgorithm}
			\caption{FindTotalSum}
			\begin{algorithmic}[1]
				\Procedure{FindTotalSum}{$A, B, \rho$}
					\State $A \leftarrow$ ConvertToList($A$)
					\State $A \leftarrow$ MergeSort($A$)
					\State $T$ := 0
					\State $S$ := $\emptyset$
					\For{$i\in\{n,\dots,1\}$}
						\If{$T+a_i\leq B$}
							\State $T\leftarrow T+a_i$
							\State $S\leftarrow S\cup \{a_i\}$
						\EndIf
					\EndFor
				\EndProcedure
			\end{algorithmic}
		\end{breakablealgorithm}
		\subsubsection*{Laufzeitbeweis}
		Der Algorithmus soll die Laufzeitschranke von $\Ovon{n\cdot\log{n}}$ nicht überschreiten, was zu beweisen gilt:\n
		Eine Menge in eine Liste zu konvertieren ist bei der Erzeugung einer verketteten Liste in linearer Laufzeit möglich.\\
		Die Liste wird nun mittels \textsc{MergeSort} sortiert. Die worst-case-Laufzeit von \textsc{MergeSort} liegt dabei in $\Ovon{n\cdot\log{n}}$.\\
		Die Schleife (Zeile 6 bis 11) wird genau $n$ mal ausgeführt. Alle Operationen in der Schleife lassen sich in konstanter Zeit bewerkstelligen, sofern man die Menge genügend schlau implementiert (z.B. als verkettete Liste).\n
		Somit liegt die Gesamtlaufzeit auch in $\Ovon{n\cdot\log{n}}$.\qed
		\subsubsection*{Korrektheitsbeweis}
		Zunächst kann man allgemein sagen, dass $a_i>a_{i+1}$ mit $1\leq i\leq n$ gilt und das alle Elemente übersprungen werden für die $a_i>B$ gilt.\n
		Man kann nun zwischen zwei Fällen unterscheiden: Entweder es gibt Elemente $a_i$ für die gilt $a_i>\frac{B}{2}$ mit $1\leq i\leq n$ oder es gibt sie nicht.
		\paragraph{(a)}
		Für den Fall, dass es solche Elemente gibt, nehmen wir eines der Elemente auf und es gilt sofort $T\geq\frac{B}{2}$.
		\paragraph{(b)}
		Für den Fall, dass es solche Elemente nicht gibt und für alle Elemente $a_i$ mit $1\leq i\leq n$ die Ungleichung $a_i\leq\frac{B}{2}$ gilt, kann man wieder zwei Fälle unterscheiden: Entweder es wurden alle Elemente aufgenommen und es gilt $T=L^*$ oder eben nicht.
		\paragraph{(b.a)}
		Für den Fall, dass alle Elemente aufgenommen wurden und somit $T=L^*$ gilt, haben wir direkt $L^*$ als Ergebnis und wir brauchen nichts mehr zeigen, weil es das Optimum ist.
		\paragraph{(b.b)}
		Für den Fall $T\neq L^*$, so gibt es ein $a_i$ mit $1\leq i\leq n$, welches nicht aufgenommen wurde (weil sonst Fall b.a gelten würde). Es gilt trotzdem $T>\frac{B}{2}$.\\
		Da $a_i\leq\frac{B}{2}$ ist (Fall b) muss $T\leq B-a_i\leq\frac{B}{2}$ gelten.\n
		Damit gilt $T\geq \frac{B}{2}$ in jedem Fall für den angegebenen Algorithmus.\qed
	\section{}
\end{document}